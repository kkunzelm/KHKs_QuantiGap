import java.awt.*;
import java.awt.event.*;
import java.awt.geom.GeneralPath;
import java.awt.geom.Line2D;
import java.util.Vector;

import ij.IJ;
import ij.ImagePlus;
import ij.gui.ImageCanvas;
import ij.gui.ImageWindow;
import ij.gui.Roi;
import ij.gui.ShapeRoi;
import ij.plugin.filter.PlugInFilter;
import ij.process.ImageProcessor;

/**
 * TODO: Scalierte Bilder ... Koordinaten richtig
 * <p>
 * //if zoom mode is working, we should convert x and y coordinates int myx =
 * offScreenX(e.getX()); int myy = offScreenY(e.getY());
 * <p>
 * <p>
 * This plugin was developed for the quantitative margine analysis used in
 * dentistry.
 * <p>
 * The ImageJ demo "mouseListener.java" gave the first important ideas, how to
 * implement it. MouseListener and MouseMotionListener listen for mouse events
 * generated by the current image. Another very valuable source was:
 * MultiColor_Graphic_Overlay.java
 */
public class KHKs_QuantiGap implements PlugInFilter, MouseListener, MouseMotionListener, KeyListener {
	static Vector images = new Vector();
	ImagePlus img;
	ImageCanvas ic;
	Vector list = new Vector();
	// Vector lines = new Vector();
	int np = 0; // number of points in polyline

	// three arrays to store the line data
	// x = x-coordinate
	// y = y-coordinate
	// criterionLabel as number
	// meaningful examples: 0 = perfect margin / potential color code = green
	// 1 = marginal gap / potential color code = red
	// 2 = artifact/no evaluation possible / potential color code = yellow
	int[] xCoord = new int[1000];
	int[] yCoord = new int[1000];
	int[] criterionLabel = new int[1000];
	GeneralPath[] gp = new GeneralPath[1000];

	int x1, y1; // Starting point of line segment
	int lastx1, lasty1; // End of last general path segment
	int lastx2, lasty2; // last end point of line segment before mouse was moved
	int x2, y2; // end point of line segment
	Color c = new Color(255, 255, 255);
	Graphics2D g; // is this the right place ?

	boolean firstPoint = true;
	boolean firstPath = true;
	boolean newPath = true;

	int gpIndex = 0; // index for generalpath array

	public int setup(String arg, ImagePlus img) {

		this.img = img;
		IJ.register(KHKs_QuantiGap.class);
		return DOES_ALL + NO_CHANGES;
	}

	public void run(ImageProcessor ip) {
		Integer id = new Integer(img.getID());
		if (images.contains(id)) {
			IJ.log("Already listening to this image");
			return;
		} else {
			ImageWindow win = img.getWindow();
			ic = win.getCanvas();
			ic.addKeyListener(this);
			ic.addMouseListener(this);
			ic.addMouseMotionListener(this);

			images.addElement(id);
		}

	}

	void addElement(Vector list, Shape shape, Color color, int lineWidth) {
		Roi roi = new ShapeRoi(shape);
		roi.setInstanceColor(color);
		roi.setLineWidth(lineWidth);
		list.addElement(roi);
	}

	public void mouseClicked(MouseEvent e) {
		// just evaluated if mousePressed and mouseRelease it the same position
		// in case of movement during clicking not evaluated.
		if (e.getClickCount() == 2) {
			lastx1 = x1;
			lasty1 = y1;
			firstPoint = true;
			addElement(list, gp[gpIndex], c, 2);
			ic.setDisplayList(list);
			gpIndex = gpIndex + 1;
		}

	}

	public void mousePressed(MouseEvent e) {
		x1 = e.getX();
		y1 = e.getY();
		xCoord[np] = x1;
		yCoord[np] = y1;
		np++;
		int offscreenX = ic.offScreenX(x1);
		int offscreenY = ic.offScreenY(y2);
		IJ.log("Mouse pressed: " + offscreenX + "," + offscreenY);

		accumulatePolyLine(x1, y1);

	}

	public void mouseReleased(MouseEvent e) {
	}

	public void mouseMoved(MouseEvent e) {
		lastx2 = x2;
		lasty2 = y2;

		x2 = e.getX();
		y2 = e.getY();

		drawLine();

	}

	public void mouseDragged(MouseEvent e) {
	}

	public void mouseExited(MouseEvent e) {
	}

	public void mouseEntered(MouseEvent e) {
	}

	private void accumulatePolyLine(int x, int y) {

		// this.x1 = x;
		// this.x2 = y;
		if (firstPoint && firstPath) {

			/*
			 * from the web:
			 * 
			 * child [] children=new child[5]; classname[] arrayname=new classname[no of
			 * objects]; then u write
			 * 
			 * child[0]=new child(23); classname[objectnumber]=new classname(age);
			 * 
			 * child(23) is a parameterized construtor of class child.
			 */

			gp[gpIndex] = new GeneralPath();
			gp[gpIndex].moveTo(x, y);

			firstPoint = false;
			firstPath = false;
		} else if (firstPoint) {

			gp[gpIndex] = new GeneralPath();
			gp[gpIndex].moveTo(lastx1, lasty1);
			firstPoint = false;
		} else {

			gp[gpIndex].lineTo(x, y);

		}
		ic.repaint();
	}

	public void drawLine() {

		g = (Graphics2D) ic.getGraphics();
		g.setXORMode(c);

		Line2D line1 = new Line2D.Double(10, 10, 30, 30);
		Line2D line2 = new Line2D.Double(30, 30, 80, 30);
		Line2D line3 = new Line2D.Double(80, 30, 80, 100);

		Line2D eraseLine = new Line2D.Double(x1, y1, lastx2, lasty2);
		Line2D line = new Line2D.Double(x1, y1, x2, y2);
		g.setColor(Color.blue);
		g.setStroke(new BasicStroke(4));
		g.draw(eraseLine);
		g.draw(line);
		g.draw(line1);
		g.draw(line2);
		g.draw(line3);

	}

	public void keyTyped(KeyEvent evt) {
		// The user has typed a character, while the
		// applet has the input focus. If it is one
		// of the keys that represents a color, change
		// the color of the square and redraw the applet.

		char ch = evt.getKeyChar(); // The character typed.

		if (ch == 'B' || ch == 'b') {

			c = Color.BLUE;

			System.out.println("B pressed" + c);
		} else if (ch == 'G' || ch == 'g') {
			c = Color.GREEN;

			System.out.println("G pressed" + c);
		} else if (ch == 'R' || ch == 'r') {
			c = Color.RED;

			System.out.println("R pressed" + c);
		} else if (ch == 'Y' || ch == 'y') {
			c = Color.YELLOW;

			System.out.println("Y pressed" + c);
		} else if (ch == 'Q' || ch == 'q') {

			System.out.println("Q (quit)pressed");

		}

	} // end keyTyped()

	public void keyPressed(KeyEvent evt) {
		// empty method, required by the KeyListener Interface
	}

	public void keyReleased(KeyEvent evt) {
		// empty method, required by the KeyListener Interface
	}
}

/*
 *
 * To Create a Vector
 * 
 * You must import either import java.util.Vector; or import java.util.*;.
 * Vectors are implemented with an array, and when that array is full and an
 * additional element is added, a new array must be allocated. Because it takes
 * time to create a bigger array and copy the elements from the old array to the
 * new array, it is a little faster to create a Vector with a size that it will
 * commonly be when full. Of course, if you knew the final size, you could
 * simply use an array. However, for non-critical sections of code programmers
 * typically don't specify an initial size.
 * 
 * Create a Vector with default initial size Vector v = new Vector(); Create a
 * Vector with an initial size Vector v = new Vector(300); Common Vector Methods
 * 
 * There are many useful methods in the Vector class and its parent classes.
 * Here are some of the most useful. v is a Vector, i is an int index, o is an
 * Object. Method Description v.add(o) adds Object o to Vector v v.add(i, o)
 * Inserts Object o at index i, shifting elements up as necessary. v.clear()
 * removes all elements from Vector v v.contains(o) Returns true if Vector v
 * contains Object o v.firstElement(i) Returns the first element. v.get(i)
 * Returns the object at int index i. v.lastElement(i) Returns the last element.
 * v.listIterator() Returns a ListIterator that can be used to go over the
 * Vector. This is a useful alternative to the for loop. v.remove(i) Removes the
 * element at position i, and shifts all following elements down. v.set(i,o)
 * Sets the element at index i to o. v.size() Returns the number of elements in
 * Vector v. v.toArray(Object[]) The array parameter can be any Object subclass
 * (eg, String). This returns the vector values in that array (or a larger array
 * if necessary). This is useful when you need the generality of a Vector for
 * input, but need the speed of arrays when processing the data.
 *
 * 
 * The following methods have been changed from the old to the new Vector API.
 * Old Method New Method void addElement(Object) boolean add(Object) void
 * copyInto(Object[]) Object[] toArray() Object elementAt(int) Object get(int)
 * Enumeration elements() Iterator iterator() ListIterator listIterator() void
 * insertElementAt(Object, int) void add(index, Object) void removeAllElements()
 * void clear() boolean removeElement(Object) boolean remove(Object) void
 * removeElementAt(int) void remove(int) void setElementAt(int) Object set(int,
 * Object)
 *
 * Insuring use of the new API
 * 
 * When you create a Vector, you can assign it to a List (a Collections
 * interface). This will guarantee that only the List methods are called.
 * 
 * Vector v1 = new Vector(); // allows old or new methods. List v2 = new
 * Vector(); // allows only the new (List) methods.
 *
 * 
 */