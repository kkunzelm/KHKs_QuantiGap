import java.awt.*;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.geom.Ellipse2D;
import java.awt.geom.GeneralPath;
import java.awt.geom.Rectangle2D;
import java.util.Vector;

import ij.IJ;
import ij.ImagePlus;
import ij.gui.*;
import ij.plugin.filter.PlugInFilter;
import ij.process.ImageProcessor;

/**
 * This plugin was developed for the quantitative margine analysis used in
 * dentistry.
 * <p>
 * The ImageJ demo "mouseListener.java" gave the first important ideas, how to
 * implement it. MouseListener and MouseMotionListener listen for mouse events
 * generated by the current image.
 */
public class Mouse_Listener_KH implements PlugInFilter, MouseListener, MouseMotionListener {
	static Vector images = new Vector();
	ImagePlus img;
	ImageCanvas ic;
	Vector list = new Vector();
	// Vector lines = new Vector();
	int np = 0; // number of points in polyline

	// three arrays to store the line data
	// x = x-coordinate
	// y = y-coordinate
	// criterionLabel as number
	// meaningful examples: 0 = perfect margin
	// 1 = marginal gap
	// 2 = xxx
	int[] xCoord = new int[1000];
	int[] yCoord = new int[1000];
	int[] criterionLabel = new int[1000];

	int x1, y1; // Starting point of line segment
	int lastx2, lasty2; // last end point of line segment before mouse was moved
	int x2, y2; // end point of line segment
	Color c = new Color(255, 255, 255);
	Graphics g; // is this the right place ?

	public static String modifiers(int flags) {
		String s = " [ ";
		if (flags == 0)
			return "";
		if ((flags & Event.SHIFT_MASK) != 0)
			s += "Shift ";
		if ((flags & Event.CTRL_MASK) != 0)
			s += "Control ";
		if ((flags & Event.META_MASK) != 0)
			s += "Meta (right button) ";
		if ((flags & Event.ALT_MASK) != 0)
			s += "Alt ";
		s += "]";
		if (s.equals(" [ ]"))
			s = " [no modifiers]";
		return s;
	}

	public int setup(String arg, ImagePlus img) {

		this.img = img;
		IJ.register(Mouse_Listener_KH.class);
		return DOES_ALL + NO_CHANGES;
	}

	public void run(ImageProcessor ip) {
		Integer id = new Integer(img.getID());
		if (images.contains(id)) {
			IJ.log("Already listening to this image");
			return;
		} else {
			ImageWindow win = img.getWindow();
			ic = win.getCanvas();
			ic.addMouseListener(this);
			ic.addMouseMotionListener(this);

			// the next two lines are mysterious for me
			// they are commented in the original mouseListener
			// but if I uncomment them, the line will not be deleted, now it appears as a
			// polyline
			int tool = Toolbar.getInstance().addTool("Test Tool");
			Toolbar.getInstance().setTool(tool);

			images.addElement(id);
			// display two red lines
			GeneralPath path = new GeneralPath();
			path.moveTo(10.5f, 10.5f);
			path.lineTo(100.5f, 100.5f);
			path.moveTo(10.5f, 70.5f);
			path.lineTo(80.5f, 110.5f);
			addElement(list, path, Color.red, 2);

			// display a green circle
			addElement(list, new Ellipse2D.Float(25.5f, 120.5f, 50f, 50f), Color.green, 4);
			ic.setDisplayList(list);

			// wait 2 seconds then display a blue box
			IJ.wait(2000);
			addElement(list, new Rectangle2D.Float(120.5f, 20.5f, 50f, 50f), Color.blue, 8);
			ic.repaint();

			// wait 2 seconds then remove green circle
			IJ.wait(2000);
			list.remove(1);
			ic.repaint();

		}
	}

	void addElement(Vector list, Shape shape, Color color, int lineWidth) {
		Roi roi = new ShapeRoi(shape);
		roi.setInstanceColor(color);
		roi.setLineWidth(lineWidth);
		list.addElement(roi);
	}

	public void mouseClicked(MouseEvent e) {
		// just evaluated if mousePressed and mouseRelease it the same position
		// in case of movement during clicking not evaluated.

	}

	public void mousePressed(MouseEvent e) {
		x1 = e.getX();
		y1 = e.getY();
		xCoord[np] = x1;
		yCoord[np] = y1;
		np++;
		int offscreenX = ic.offScreenX(x1);
		int offscreenY = ic.offScreenY(y2);
		IJ.log("Mouse pressed: " + offscreenX + "," + offscreenY + modifiers(e.getModifiers()));
		// IJ.log("Right button: "+((e.getModifiers()&Event.META_MASK)!=0));

		if (e.getClickCount() == 2) {
			c = new Color(0, 0, 255);
		} else {
			c = new Color(0, 255, 0);
		}

	}

	public void mouseReleased(MouseEvent e) {

		if (e.getClickCount() == 2) {
			// drawPolyLine();
		}

	}

	public void mouseMoved(MouseEvent e) {
		lastx2 = x2;
		lasty2 = y2;

		x2 = e.getX();
		y2 = e.getY();

		drawLine();
	}

	public void mouseDragged(MouseEvent e) {
	}

	public void mouseExited(MouseEvent e) {
	}

	public void mouseEntered(MouseEvent e) {
	}

	public void drawLine() {
		// ImageCanvas ic = img.getCanvas();
		// if (ic==null) return;
		// Graphics g ...
		g = ic.getGraphics();

		g.setXORMode(c);
		g.drawLine(ic.screenX(x1), ic.screenY(y1), ic.screenX(lastx2), ic.screenY(lasty2));
		g.drawLine(ic.screenX(x1), ic.screenY(y1), ic.screenX(x2), ic.screenY(y2));

	}

	public void drawPolyLine() {

		// int x2Points[] = {0, 100, 0, 100};
		// int y2Points[] = {0, 50, 50, 0};

		g.setXORMode(Color.GREEN);
		// g.drawPolyline(x2Points, y2Points, x2Points.length);
		g.drawPolyline(xCoord, yCoord, xCoord.length);

	}

}

/*
 *
 * To Create a Vector
 * 
 * You must import either import java.util.Vector; or import java.util.*;.
 * Vectors are implemented with an array, and when that array is full and an
 * additional element is added, a new array must be allocated. Because it takes
 * time to create a bigger array and copy the elements from the old array to the
 * new array, it is a little faster to create a Vector with a size that it will
 * commonly be when full. Of course, if you knew the final size, you could
 * simply use an array. However, for non-critical sections of code programmers
 * typically don't specify an initial size.
 * 
 * Create a Vector with default initial size Vector v = new Vector(); Create a
 * Vector with an initial size Vector v = new Vector(300); Common Vector Methods
 * 
 * There are many useful methods in the Vector class and its parent classes.
 * Here are some of the most useful. v is a Vector, i is an int index, o is an
 * Object. Method Description v.add(o) adds Object o to Vector v v.add(i, o)
 * Inserts Object o at index i, shifting elements up as necessary. v.clear()
 * removes all elements from Vector v v.contains(o) Returns true if Vector v
 * contains Object o v.firstElement(i) Returns the first element. v.get(i)
 * Returns the object at int index i. v.lastElement(i) Returns the last element.
 * v.listIterator() Returns a ListIterator that can be used to go over the
 * Vector. This is a useful alternative to the for loop. v.remove(i) Removes the
 * element at position i, and shifts all following elements down. v.set(i,o)
 * Sets the element at index i to o. v.size() Returns the number of elements in
 * Vector v. v.toArray(Object[]) The array parameter can be any Object subclass
 * (eg, String). This returns the vector values in that array (or a larger array
 * if necessary). This is useful when you need the generality of a Vector for
 * input, but need the speed of arrays when processing the data.
 *
 * 
 * The following methods have been changed from the old to the new Vector API.
 * Old Method New Method void addElement(Object) boolean add(Object) void
 * copyInto(Object[]) Object[] toArray() Object elementAt(int) Object get(int)
 * Enumeration elements() Iterator iterator() ListIterator listIterator() void
 * insertElementAt(Object, int) void add(index, Object) void removeAllElements()
 * void clear() boolean removeElement(Object) boolean remove(Object) void
 * removeElementAt(int) void remove(int) void setElementAt(int) Object set(int,
 * Object)
 *
 * Insuring use of the new API
 * 
 * When you create a Vector, you can assign it to a List (a Collections
 * interface). This will guarantee that only the List methods are called.
 * 
 * Vector v1 = new Vector(); // allows old or new methods. List v2 = new
 * Vector(); // allows only the new (List) methods.
 *
 * 
 */